import numpy as np
import random
import math



MAX_SPAN=37
class hi_lo_t:
    def __init__(self, hi, lo):
        self.hi=hi
        self.lo=lo

class patdef_t:
    def __init__(self, id, ly0, ly1, ly2, ly3, ly4, ly5):
        self.id=id
        self.ly0=ly0
        self.ly1=ly1
        self.ly2=ly2
        self.ly3=ly3
        self.ly4=ly4
        self.ly5=ly5
# ly0=hi_lo_t(-8,-11)
# print(ly0)
# pat_l5=patdef_t(6,hi_lo_t(-8,-11),hi_lo_t(-5,-9),hi_lo_t(0,-3),hi_lo_t(3,0),hi_lo_t(9,5),hi_lo_t(11,8))
# #print(pat_l5.ly0.hi)
# print(pat_l5.id)
# #z=hi
# print(pat_l5.ly1.lo)

def mirror_patdef(pat,id):
    ly0_h=pat.ly0.lo*(-1)
    ly0_l=pat.ly0.hi*(-1)
    ly1_h=pat.ly1.lo*(-1)
    ly1_l=pat.ly1.hi*(-1)
    ly2_h=pat.ly2.lo*(-1)
    ly2_l=pat.ly2.hi*(-1)
    ly3_h=pat.ly3.lo*(-1)
    ly3_l=pat.ly3.hi*(-1)
    ly4_h=pat.ly4.lo*(-1)
    ly4_l=pat.ly4.hi*(-1)
    ly5_h=pat.ly5.lo*(-1)
    ly5_l=pat.ly5.hi*(-1)
    ly0=hi_lo_t(ly0_h,ly0_l)
    ly1=hi_lo_t(ly1_h,ly1_l)
    ly2=hi_lo_t(ly2_h,ly2_l)
    ly3=hi_lo_t(ly3_h,ly3_l)
    ly4=hi_lo_t(ly4_h,ly4_l)
    ly5=hi_lo_t(ly5_h,ly5_l)
    result=patdef_t(id,ly0,ly1,ly2,ly3,ly4,ly5)
    return result

pat_straight=patdef_t(15,hi_lo_t(1,-1),hi_lo_t(1,-1),hi_lo_t(1,-1),hi_lo_t(0,0),hi_lo_t(1,-1),hi_lo_t(1,-1))
pat_l=patdef_t(14,hi_lo_t(-1,-4),hi_lo_t(0,-3),hi_lo_t(1,-1),hi_lo_t(1,-1),hi_lo_t(3,0),hi_lo_t(4,1))
pat_r=mirror_patdef(pat_l,pat_l.id-1)
pat_l2=patdef_t(12,hi_lo_t(-2,-5),hi_lo_t(1,-4),hi_lo_t(1,-1),hi_lo_t(1,-1),hi_lo_t(4,1),hi_lo_t(5,2))
pat_r2=mirror_patdef(pat_l2,pat_l2.id-1)
pat_l3=patdef_t(10,hi_lo_t(-5,-8),hi_lo_t(-4,-7),hi_lo_t(0,-3),hi_lo_t(2,-2),hi_lo_t(7,4),hi_lo_t(8,5))
pat_r3=mirror_patdef(pat_l3,pat_l3.id-1)
pat_l4=patdef_t(8,hi_lo_t(-5,-8),hi_lo_t(-4,-7),hi_lo_t(0,-3),hi_lo_t(2,-2),hi_lo_t(7,4),hi_lo_t(8,5))
pat_r4=mirror_patdef(pat_l4,pat_l4.id-1)
pat_l5=patdef_t(6,hi_lo_t(-8,-11),hi_lo_t(-5,-9),hi_lo_t(0,-3),hi_lo_t(3,0),hi_lo_t(9,5),hi_lo_t(11,8))
pat_r5=mirror_patdef(pat_l5,pat_l5.id-1)
pat_l6=patdef_t(4,hi_lo_t(-11,-15),hi_lo_t(-9,-11),hi_lo_t(4,-9),hi_lo_t(9,4),hi_lo_t(11,9),hi_lo_t(15,11))
pat_r6=mirror_patdef(pat_l6,pat_l6.id-1)
pat_l7=patdef_t(2,hi_lo_t(-10,-18),hi_lo_t(-6,-14),hi_lo_t(2,-9),hi_lo_t(9,2),hi_lo_t(14,6),hi_lo_t(18,10))
pat_r7=mirror_patdef(pat_l7,pat_l7.id-1)

patlist=[pat_straight,pat_l,pat_r,pat_l2,pat_r2,pat_l3,pat_r3,pat_l4,pat_r4,pat_l5,pat_r5,pat_l6,pat_r6,pat_l7,pat_r7]



#for i in range(len(patlist)):
    #corr_pat_id=np.zeros(len(patlist))
    #corr_pat_id[i]=patlist[i].id

def get_ly_mask(ly_pat):
    m_ly0=np.zeros(MAX_SPAN)
    m_ly1=np.zeros(MAX_SPAN)
    m_ly2=np.zeros(MAX_SPAN)
    m_ly3=np.zeros(MAX_SPAN)
    m_ly4=np.zeros(MAX_SPAN)
    m_ly5=np.zeros(MAX_SPAN)
    center=math.ceil(MAX_SPAN/2)
    a_lo=ly_pat.ly0.lo+center
    a_hi=ly_pat.ly0.hi+center+1
    b_lo=ly_pat.ly1.lo+center
    b_hi=ly_pat.ly1.hi+center+1
    c_lo=ly_pat.ly2.lo+center
    c_hi=ly_pat.ly2.hi+center+1
    d_lo=ly_pat.ly3.lo+center
    d_hi=ly_pat.ly3.hi+center+1
    e_lo=ly_pat.ly4.lo+center
    e_hi=ly_pat.ly4.hi+center+1
    f_lo=ly_pat.ly5.lo+center
    f_hi=ly_pat.ly5.hi+center+1
    for a in (a_lo,a_hi):
        m_ly0[a]=1
    for b in (b_lo,b_hi):
        m_ly1[b]=1
    for c in (c_lo,c_hi):
        m_ly2[c]=1
    for d in (d_lo,d_hi):
        m_ly3[d]=1
    for e in (e_lo,e_hi):
        m_ly4[e]=1
    for f in (f_lo,f_hi):
        m_ly5[f]=1
    m_vec=[m_ly0,m_ly1,m_ly2,m_ly3,m_ly4,m_ly5]
    return m_vec

pats_m=[]
for w in range(len(patlist)):
    pats_m.append(get_ly_mask(patlist[w])

print(pats_m[0][1])



# # pat=1  span=37
# # ly0 ----------------------------xxxxxxxxx
# # ly1 ------------------------xxxxxxxxx----
# # ly2 ----------------xxxxxxxxxxxx---------
# # ly3 ---------xxxxxxxx--------------------
# # ly4 ----xxxxxxxxx------------------------
# # ly5 xxxxxxxxx----------------------------
# # --pat=2  span=37
# # ly0 xxxxxxxxx----------------------------
# # ly1 ----xxxxxxxxx------------------------
# # ly2 ---------xxxxxxxxxxxx----------------
# # ly3 --------------------xxxxxxxx---------
# # ly4 ------------------------xxxxxxxxx----
# # ly5 ----------------------------xxxxxxxxx
# # --pat=3  span=31
# # ly0 --------------------------xxxxx
# # ly1 ------------------------xxx----
# # ly2 -----------xxxxxxxxxxxxxx------
# # ly3 ------xxxxxx-------------------
# # ly4 ----xxx------------------------
# # ly5 xxxxx--------------------------
# # --pat=4  span=31
# # ly0 xxxxx--------------------------
# # ly1 ----xxx------------------------
# # ly2 ------xxxxxxxxxxxxxx-----------
# # ly3 -------------------xxxxxx------
# # ly4 ------------------------xxx----
# # ly5 --------------------------xxxxx
# # --pat=5  span=23
# # ly0 -------------------xxxx
# # ly1 ----------------xxxxx--
# # ly2 -----------xxxx--------
# # ly3 --------xxxx-----------
# # ly4 --xxxxx----------------
# # ly5 xxxx-------------------
# # --pat=6  span=23
# # ly0 xxxx-------------------
# # ly1 --xxxxx----------------
# # ly2 --------xxxx-----------
# # ly3 -----------xxxx--------
# # ly4 ----------------xxxxx--
# # ly5 -------------------xxxx
# # --pat=7  span=17
# # ly0 -------------xxxx
# # ly1 ------------xxxx-
# # ly2 --------xxxx-----
# # ly3 ------xxxxx------
# # ly4 -xxxx------------
# # ly5 xxxx-------------
# # --pat=8  span=17
# # ly0 xxxx-------------
# # ly1 -xxxx------------
# # ly2 -----xxxx--------
# # ly3 ------xxxxx------
# # ly4 ------------xxxx-
# # ly5 -------------xxxx
# # --pat=9  span=17
# # ly0 -------------xxxx
# # ly1 ------------xxxx-
# # ly2 --------xxxx-----
# # ly3 ------xxxxx------
# # ly4 -xxxx------------
# # ly5 xxxx-------------
# # --pat=10  span=17
# # ly0 xxxx-------------
# # ly1 -xxxx------------
# # ly2 -----xxxx--------
# # ly3 ------xxxxx------
# # ly4 ------------xxxx-
# # ly5 -------------xxxx
# # --pat=11  span=11
# # ly0 -------xxxx
# # ly1 ----xxxxxx-
# ly2 ----xxx----
# ly3 ----xxx----
# ly4 -xxxx------
# ly5 xxxx-------
# --pat=12  span=11
# ly0 xxxx-------
# ly1 -xxxxxx----
# ly2 ----xxx----
# ly3 ----xxx----
# ly4 ------xxxx-
# ly5 -------xxxx
# --pat=13  span=9
# ly0 -----xxxx
# ly1 ----xxxx-
# ly2 ---xxx---
# ly3 ---xxx---
# ly4 -xxxx----
# ly5 xxxx-----
# --pat=14  span=9
# ly0 xxxx-----
# ly1 -xxxx----
# ly2 ---xxx---
# ly3 ---xxx---
# ly4 ----xxxx-
# ly5 -----xxxx
# --pat=15  span=3
# ly0 xxx
# ly1 xxx
# ly2 xxx
# ly3 -x-
# ly4 xxx
# ly5 xxx


#python implementation of the pat_unit.vhd behavior


# def process_pat(ly0,ly1,ly2,ly3,ly4,ly5):
#     "this function will act like the pat_unit architecture and return us pat_id and ly_c"

#     return pat_id,ly_c

import numpy as np
import random
import math
import csv

class hi_lo_t:
    def __init__(self,hi,lo):
        self.hi=hi
        self.lo=lo

class patdef_t:
    def __init__(self, id, ly0, ly1, ly2, ly3, ly4, ly5):
        self.id=id
        self.ly0=ly0
        self.ly1=ly1
        self.ly2=ly2
        self.ly3=ly3
        self.ly4=ly4
        self.ly5=ly5

def mirror_patdef(pat,id):
    ly0_h=pat.ly0.lo*(-1)
    ly0_l=pat.ly0.hi*(-1)
    ly1_h=pat.ly1.lo*(-1)
    ly1_l=pat.ly1.hi*(-1)
    ly2_h=pat.ly2.lo*(-1)
    ly2_l=pat.ly2.hi*(-1)
    ly3_h=pat.ly3.lo*(-1)
    ly3_l=pat.ly3.hi*(-1)
    ly4_h=pat.ly4.lo*(-1)
    ly4_l=pat.ly4.hi*(-1)
    ly5_h=pat.ly5.lo*(-1)
    ly5_l=pat.ly5.hi*(-1)
    ly0=hi_lo_t(ly0_h,ly0_l)
    ly1=hi_lo_t(ly1_h,ly1_l)
    ly2=hi_lo_t(ly2_h,ly2_l)
    ly3=hi_lo_t(ly3_h,ly3_l)
    ly4=hi_lo_t(ly4_h,ly4_l)
    ly5=hi_lo_t(ly5_h,ly5_l)
    result=patdef_t(id,ly0,ly1,ly2,ly3,ly4,ly5)
    return result


#define all the patterns; make subject to change
pat_straight=patdef_t(15,hi_lo_t(1,-1),hi_lo_t(1,-1),hi_lo_t(1,-1),hi_lo_t(0,0),hi_lo_t(1,-1),hi_lo_t(1,-1))
pat_l=patdef_t(14,hi_lo_t(-1,-4),hi_lo_t(0,-3),hi_lo_t(1,-1),hi_lo_t(1,-1),hi_lo_t(3,0),hi_lo_t(4,1))
pat_r=mirror_patdef(pat_l,pat_l.id-1)
pat_l2=patdef_t(12,hi_lo_t(-2,-5),hi_lo_t(1,-4),hi_lo_t(1,-1),hi_lo_t(1,-1),hi_lo_t(4,1),hi_lo_t(5,2))
pat_r2=mirror_patdef(pat_l2,pat_l2.id-1)
pat_l3=patdef_t(10,hi_lo_t(-5,-8),hi_lo_t(-4,-7),hi_lo_t(0,-3),hi_lo_t(2,-2),hi_lo_t(7,4),hi_lo_t(8,5))
pat_r3=mirror_patdef(pat_l3,pat_l3.id-1)
pat_l4=patdef_t(8,hi_lo_t(-5,-8),hi_lo_t(-4,-7),hi_lo_t(0,-3),hi_lo_t(2,-2),hi_lo_t(7,4),hi_lo_t(8,5))
pat_r4=mirror_patdef(pat_l4,pat_l4.id-1)
pat_l5=patdef_t(6,hi_lo_t(-8,-11),hi_lo_t(-5,-9),hi_lo_t(0,-3),hi_lo_t(3,0),hi_lo_t(9,5),hi_lo_t(11,8))
pat_r5=mirror_patdef(pat_l5,pat_l5.id-1)
pat_l6=patdef_t(4,hi_lo_t(-11,-15),hi_lo_t(-9,-11),hi_lo_t(4,-9),hi_lo_t(9,4),hi_lo_t(11,9),hi_lo_t(15,11))
pat_r6=mirror_patdef(pat_l6,pat_l6.id-1)
pat_l7=patdef_t(2,hi_lo_t(-10,-18),hi_lo_t(-6,-14),hi_lo_t(2,-9),hi_lo_t(9,2),hi_lo_t(14,6),hi_lo_t(18,10))
pat_r7=mirror_patdef(pat_l7,pat_l7.id-1)

patlist=[pat_straight,pat_l,pat_r,pat_l2,pat_r2,pat_l3,pat_r3,pat_l4,pat_r4,pat_l5,pat_r5,pat_l6,pat_r6,pat_l7,pat_r7]


def process_pat(patlist,ly0_x,ly1_x,ly2_x,ly3_x,ly4_x,ly5_x,MAX_SPAN=37):

    corr_pat_id=[patlist[0].id,patlist[1].id,patlist[2].id, patlist[3].id,patlist[4].id,patlist[5].id,patlist[6].id,patlist[7].id,patlist[8].id,patlist[9].id,patlist[10].id,patlist[11].id,patlist[12].id,patlist[13].id,patlist[14].id]

    N_LAYERS=6
    len_patlist=len(patlist)
    def count_ones(ones_vec):
        n_ones=0
        for i in range(len(ones_vec)):
            if ones_vec[i]==1:
                n_ones=n_ones+1
        return n_ones;



    def get_ly_mask(ly_pat):
        m_ly0=np.zeros(MAX_SPAN)
        m_ly1=np.zeros(MAX_SPAN)
        m_ly2=np.zeros(MAX_SPAN)
        m_ly3=np.zeros(MAX_SPAN)
        m_ly4=np.zeros(MAX_SPAN)
        m_ly5=np.zeros(MAX_SPAN)
        center=math.ceil(MAX_SPAN/2)
        a_lo=ly_pat.ly0.lo+center
        a_hi=ly_pat.ly0.hi+center+1
        b_lo=ly_pat.ly1.lo+center
        b_hi=ly_pat.ly1.hi+center+1
        c_lo=ly_pat.ly2.lo+center
        c_hi=ly_pat.ly2.hi+center+1
        d_lo=ly_pat.ly3.lo+center
        d_hi=ly_pat.ly3.hi+center+1
        e_lo=ly_pat.ly4.lo+center
        e_hi=ly_pat.ly4.hi+center+1
        f_lo=ly_pat.ly5.lo+center
        f_hi=ly_pat.ly5.hi+center+1
        for a in (a_lo,a_hi):
            m_ly0[a]=1
        for b in (b_lo,b_hi):
            m_ly1[b]=1
        for c in (c_lo,c_hi):
            m_ly2[c]=1
        for d in (d_lo,d_hi):
            m_ly3[d]=1
        for e in (e_lo,e_hi):
            m_ly4[e]=1
        for f in (f_lo,f_hi):
            m_ly5[f]=1
        m_vec=[m_ly0,m_ly1,m_ly2,m_ly3,m_ly4,m_ly5]
        return m_vec



    def get_lc_id(patlist,ly0_x,ly1_x,ly2_x,ly3_x,ly4_x,ly5_x):
        pats_m=[]
        ly0_vec=np.zeros(len_patlist)
        ly1_vec=np.zeros(len_patlist)
        ly2_vec=np.zeros(len_patlist)
        ly3_vec=np.zeros(len_patlist)
        ly4_vec=np.zeros(len_patlist)
        ly5_vec=np.zeros(len_patlist)
        ly0_ones=np.zeros(len_patlist)
        ly1_ones=np.zeros(len_patlist)
        ly2_ones=np.zeros(len_patlist)
        ly3_ones=np.zeros(len_patlist)
        ly4_ones=np.zeros(len_patlist)
        ly5_ones=np.zeros(len_patlist)
        l0_h=np.zeros(len_patlist)
        l1_h=np.zeros(len_patlist)
        l2_h=np.zeros(len_patlist)
        l3_h=np.zeros(len_patlist)
        l4_h=np.zeros(len_patlist)
        l5_h=np.zeros(len(patlist))
        ly_ct_vec=np.zeros(len_patlist)
        lc_id_vec=np.zeros(len_patlist)
        for w in range(len_patlist):
            pats_m[w]=get_ly_mask(patlist[w])
        for v in range(len_patlist):
            for h in range(MAX_SPAN):
                ly0_vec[v][h]=ly0_x[h]*pats_m[v][0][h] #represents all the ly0 vectors from all patterns and data anded together
                ly1_vec[v][h]=ly1_x[h]*pats_m[v][1][h]
                ly2_vec[v][h]=ly2_x[h]*pats_m[v][2][h]
                ly3_vec[v][h]=ly3_x[h]*pats_m[v][3][h]
                ly4_vec[v][h]=ly4_x[h]*pats_m[v][4][h]
                ly5_vec[v][h]=ly5_x[h]*pats_m[v][5][h]
        for t in range(len_patlist):
            ly0_ones[t]=count_ones(ly0_vec[t]) #number of worthy hits within each pattern type for ly0
            ly1_ones[t]=count_ones(ly1_vec[t])
            ly2_ones[t]=count_ones(ly2_vec[t])
            ly3_ones[t]=count_ones(ly3_vec[t])
            ly4_ones[t]=count_ones(ly4_vec[t])
            ly5_ones[t]=count_ones(ly5_vec[t])
        for d in range(len_patlist):
            if (ly0_ones[d]>=1):
                l0_h[d]=1
            else:
                l0_h[d]=0
            if (ly1_ones[d]>=1):
                l1_h[d]=1
            else:
                l1_h[d]=0
            if (ly2_ones[d]>=1):
                l2_h[d]=1
            else:
                l2_h[d]=0
            if (ly3_ones[d]>=1):
                l3_h[d]=1
            else:
                l3_h[d]=0
            if (ly4_ones[d]>=1):
                l4_h[d]=1
            else:
                l4_h[d]=0
            if (ly5_ones[d]>=1):
                l5_h[d]=1
            else:
                l5_h[d]=0
        for n in range(len_patlist):
            ly_ct_vec[n]=l0_h[n]+l1_h[n]+l2_h[n]+l3_h[n]+l4_h[n]+l5_h[n]
        for p in range(len_patlist):
            lc_id_vec.append([ly_ct_vec[p],corr_pat_id[p]])
        return lc_id_vec


    lc_id_vec=get_lc_id(patlist,ly0_x,ly1_x,ly2_x,ly3_x,ly4_x,ly5_x)

    def priority_encoder(lc_id_vec):
        max_lc=-1
        index=0
        store_id=0
        s_list=[]
        p_id=0
        for q in range(len(lc_id_vec)):
            if (lc_id_vec[q][0]>=max_lc):
                max_lc=lc_id_vec[q][0]
                index=q
        s_list[0]=index
        for r in range(len(lc_id_vec)):
            if (max_lc==lc_id_vec[r][0]):
                s_list.append(r)
        for s in range(len(s_list)):
            if (lc_id_vec[s][1]>=p_id):
                p_id=lc_id_vec[s][1]
                b_index=s
        best_pat=lc_id_vec[s]
        return best_pat

    [pat_id,ly_c]=priority_encoder(lc_id_vec)
    return pat_id,ly_c








