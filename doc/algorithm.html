<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-08-05 Fri 19:34 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ME0 Segment Finding</title>
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link href="theme.css" rel="stylesheet">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">ME0 Segment Finding</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org1aff28c">Segment Finding Algorithm</a>
<ul>
<li><a href="#org6a03147">Input Hits Processing</a>
<ul>
<li><a href="#orgdea7959">Cross-partition data sharing</a></li>
<li><a href="#org13b4c79">Chamber staggering</a></li>
<li><a href="#org78b68c4">Alignment ??</a></li>
<li><a href="#org4d3acfa">Centroid Identification</a></li>
</ul>
</li>
<li><a href="#orgce7ca0c">Segment Candidate Identification</a>
<ul>
<li><a href="#org7e9a04f">Centroid finding</a></li>
<li><a href="#org1836f5d">Edge Padding</a></li>
</ul>
</li>
<li><a href="#org9e654e6">Ghost Cancellation</a></li>
<li><a href="#org842d6bd">Partition Pre-Sorting</a></li>
<li><a href="#org9c51f7f">Chamber Segment Selection</a></li>
<li><a href="#orgc7383af">Centroid Coordinate Transformation</a></li>
<li><a href="#org8fc50eb">Fitting</a>
<ul>
<li><a href="#org647abfa">Quality of Fit</a></li>
<li><a href="#orgd93c620">Pipelined Multiplication</a></li>
<li><a href="#orgfdd8ea0">Reciprocal</a></li>
</ul>
</li>
<li><a href="#orga741308">Post-Fit Coordinate Transformation</a></li>
<li><a href="#org6a2bc70">Output Data Format</a>
<ul>
<li><a href="#org1d308ec">Eta</a></li>
<li><a href="#orgceb5a37">Phi</a></li>
<li><a href="#org10cfb51">Bend</a></li>
<li><a href="#org5bec022">Quality</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd03caed">Firmware Implementation</a>
<ul>
<li><a href="#org950602d">Configurable Options</a>
<ul>
<li><a href="#org68ce93e">Compile Time Options</a></li>
<li><a href="#orgd5ce02c">Runtime Options</a></li>
</ul>
</li>
<li><a href="#org846ac42">Firmware</a>
<ul>
<li><a href="#org2009a27">pat_unit.vhd</a></li>
<li><a href="#org6e3f322">pat_unit_mux.vhd</a></li>
<li><a href="#orge1c5f6b">partition.vhd</a></li>
<li><a href="#orgeb6de65">segment_selector.vhd</a></li>
<li><a href="#org873cbdd">fit.vhd</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org4f57d57">Testbench</a></li>
<li><a href="#orga5f9b82">Resource Utilization</a></li>
<li><a href="#orgc7e0fa6">Presentations</a></li>
<li><a href="#org5f2bc8c">Source Code</a></li>
</ul>
</div>
</div>

<div id="outline-container-org1aff28c" class="outline-2">
<h2 id="org1aff28c">Segment Finding Algorithm</h2>
<div class="outline-text-2" id="text-org1aff28c">
<p>
Each ME0 chamber is composed of 6 layers of GEMs.
</p>

<p>
Each layer is composed of 8 partitions in eta, each of which is split into 384 strips in phi.
</p>

<pre class="example">
[ put an image of the chamber here ]
</pre>


<p>
The trigger output of a GEM chamber is a binary readout called an &ldquo;S-bit&rdquo;, which
is the OR of two adjacent strips. The resolution of a ME0 chamber in the trigger
path is therefore 1/2 of the fundamental resolution, or 8x192 strips per layer.
</p>

<p>
In summary, and ME0 Chamber has:
</p>
<ul class="org-ul">
<li>6 layers</li>
<li>each layer has 8 eta partitions</li>
<li>each eta partition has 384 strips (192 s-bits)</li>
<li>1536 sbits / layer / bx  * 6 layers = 9216 sbits / bx</li>
</ul>

<p>
The basic goal of segment finding in ME0 is that we want to:
</p>
<ol class="org-ol">
<li>Identify multi-layer segments</li>
<li>Do some refined angular/position calculation using multi-layer hit data</li>
</ol>

<p>
In a somewhat abstract sense, the mechanism to do this segment identification is
along the lines of:
</p>

<ol class="org-ol">
<li>Need to identify segments locally
<ul class="org-ul">
<li>Create &ldquo;segment candidates&rdquo; with some sortable key field</li>
<li>Done in parallel, many times</li>
</ul></li>
<li>Need to sort segment candidates into a smaller number of output candidates
<ul class="org-ul">
<li>Development of sorting machinery can be somewhat decoupled from the exact
segment identification mechanism</li>
</ul></li>
<li>Perform some post-processing on the segment candidates to produce a refined
measurement (some kind of fit)</li>
</ol>


<div id="org1bc2f41" class="figure">
<p><img src="dataflow.svg" alt="dataflow.svg" class="org-svg" />
</p>
</div>
</div>

<div id="outline-container-org6a03147" class="outline-3">
<h3 id="org6a03147">Input Hits Processing</h3>
<div class="outline-text-3" id="text-org6a03147">
<p>
This segment finder is designed to find multi-layer segments in ME0.
</p>

<p>
The pattern finder works by looking at the chamber in two dimensional slices,
where bending in the phi direction can be observed. Each slice corresponds to 6
layers of the ME0 chamber for a given eta partition.
</p>

<p>
For example, a cross-sectional view of a muon track may look something like this
(chamber is truncated between <code>///</code> marks).
</p>

<pre class="example" id="org2528c55">
    0                                          ---&gt;                                              191
ly0 -------------+-----------------------------------------///--------------------------------------
ly1 --------------+----------------------------------------///--------------------------------------
ly2 ---------------+---------------------------------------///--------------------------------------
ly3 ----------------+--------------------------------------///--------------------------------------
ly4 -----------------+-------------------------------------///--------------------------------------
ly5 ------------------+------------------------------------///--------------------------------------

                   ^ track
</pre>

<p>
Our goal in segment finding is to:
</p>
<ol class="org-ol">
<li>Identify segments</li>
<li>Measure the position of the segment</li>
<li>Measure the bending angle of the segment</li>
</ol>
</div>

<div id="outline-container-orgdea7959" class="outline-4">
<h4 id="orgdea7959">Cross-partition data sharing</h4>
<div class="outline-text-4" id="text-orgdea7959">
<p>
How to look at eta ??
</p>
</div>
</div>
<div id="outline-container-org13b4c79" class="outline-4">
<h4 id="org13b4c79">Chamber staggering</h4>
<div class="outline-text-4" id="text-org13b4c79">
<p>
Are the chambers staggered? if so we need de-staggering
</p>
</div>
</div>
<div id="outline-container-org78b68c4" class="outline-4">
<h4 id="org78b68c4">Alignment ??</h4>
<div class="outline-text-4" id="text-org78b68c4">
<p>
Are alignment corrections required?
</p>
</div>
</div>
<div id="outline-container-org4d3acfa" class="outline-4">
<h4 id="org4d3acfa">Centroid Identification</h4>
<div class="outline-text-4" id="text-org4d3acfa">
<p>
GEM hits are read out as individual strips, and produce clusters with a fairly large distribution.
</p>

<p>
The center of this cluster corresponds to the center of the charge distribution.
</p>

<p>
Because the road based pattern finder prefers straighter patterns (higher pT), performing pattern
finding on the raw GEM hits produces a bias which truncates the outer edges of the clusters and
incorrectly assigns narrower patterns than should be found.
</p>

<p>
To prevent this, a first processing stage of the GEM data is to convert the clusters into individual
strip hits. This is currently done using a simple average within a moving window.
</p>

<pre class="example">
to be described in detail....
</pre>


<p>
When the centroid lies between strips, this filtering stage leaves two strips on at once. This is
taken into account in later processing stages.
</p>
</div>
</div>
</div>

<div id="outline-container-orgce7ca0c" class="outline-3">
<h3 id="orgce7ca0c">Segment Candidate Identification</h3>
<div class="outline-text-3" id="text-orgce7ca0c">
<p>
Centered around each strip is a pattern identification block called a &ldquo;pattern unit&rdquo;.
</p>

<p>
A pattern unit looks at a subset of the partition&rsquo;s data, and identifies segment
candidates which are roughly centered around a given strip.
</p>

<p>
To minimize latency, each bunch crossing a number of independent pattern unit
modules operate in parallel to find pattern candidates for each of the strips in the chamber.
</p>

<p>
For example, in the following diagram we show the &ldquo;window&rdquo; that a pattern unit
centered on strip #20 might look at:
</p>


<pre class="example" id="org13e5f88">
    0                   20                     ---&gt;                                              191
      ┌────────────────────────────────────┐
ly0 --│--------------+---------------------│-------------------///--------------------------------------
ly1 --│---------------+--------------------│-------------------///--------------------------------------
ly2 --│----------------+-------------------│-------------------///--------------------------------------
ly3 --│-----------------+------------------│-------------------///--------------------------------------
ly4 --│------------------+-----------------│-------------------///--------------------------------------
ly5 --│-------------------+----------------│-------------------///--------------------------------------
      └────────────────────────────────────┘
                       ^ track
</pre>

<p>
Within a pattern unit we look only at the boxed area, and can consider looking
at a slice of data ranging within +- some range (the range is determined from
the width of the maximally wide pattern). Here we use +- 18 as an example.
</p>

<pre class="example" id="orgb36e801">
┌────────────────────────────────────┐
│--------------+---------------------│
│---------------+--------------------│
│----------------+-------------------│
│-----------------+------------------│
│------------------+-----------------│
│-------------------+----------------│
└────────────────────────────────────┘
-18     &lt;--       0      --&gt;       18
</pre>

<p>
Each pattern unit looks for patterns (or roads) which are centered around a given
strip, at different bending angles.
</p>

<p>
For example, two patterns with different bending angles might look something
like:
</p>

<ul class="org-ul">
<li>Pattern #14</li>
</ul>
<pre class="example" id="orga694d5a">
ly0 xxxx-----
ly1 -xxxx----
ly2 ---xxx---
ly3 ---xxx---
ly4 ----xxxx-
ly5 -----xxxx
</pre>


<ul class="org-ul">
<li>Pattern #1</li>
</ul>
<pre class="example" id="org25073f0">
ly0 ----------------------------xxxxxxxxx
ly1 ------------------------xxxxxxxxx----
ly2 ----------------xxxxxxxxxxxx---------
ly3 ---------xxxxxxxx--------------------
ly4 ----xxxxxxxxx------------------------
ly5 xxxxxxxxx----------------------------
</pre>

<p>
If we were to overlay the above pattern #14 onto the data shown above, we would
see this:
</p>

<pre class="example" id="orgdce78d3">
┌─────────────────────────────────────┐
│-------------xx+x--------------------│
│--------------xx+x-------------------│
│----------------x+x------------------│
│----------------xx+------------------│
│------------------x+xxx--------------│
│-------------------x+xxx-------------│
└─────────────────────────────────────┘
-18     &lt;--       0       --&gt;       18
</pre>

<p>
In this case, we can see that 6 hits (designated by <code>+</code>) fall within the pattern
mask (designated by <code>x</code>), so we say that for this pattern the layer count is 6.
</p>

<p>
The high layer count (6) is because this pattern is a good match for the actual data.
</p>

<p>
If instead we overlay pattern #1 on this data we see
</p>

<pre class="example" id="org376e96a">
┌─────────────────────────────────────┐
│---------------+------------xxxxxxxxx│
│----------------+-------xxxxxxxxx----│
│----------------x+xxxxxxxxxx---------│
│---------xxxxxxxx-+------------------│
│----xxxxxxxxx------+-----------------│
│xxxxxxxxx-----------+----------------│
└─────────────────────────────────────┘
-18     &lt;--       0       --&gt;       18
</pre>

<p>
In this case only one of the hits falls within the pattern mask, so the layer
count is only 1. Following this example, we can use the layer count for each
pattern as a metric for the quality of the pattern.
</p>

<p>
For the entire collection of patterns in a pattern unit, a sorting tree looks
through this collection of data and returns a single pattern which is determined
to have the highest &ldquo;quality&rdquo;.
</p>

<p>
The sorting metric is:
</p>
<ol class="org-ol">
<li>Choose the pattern with the highest layer count</li>
<li>If multiple patterns have the same layer count, choose the one with the
highest pattern id (higher pattern IDs correspond to straighter patterns, or
higher momentum particles).</li>
</ol>

<p>
The single pattern that is chosen for each pattern unit
</p>
<ol class="org-ol">
<li>Layer count (the number of layers hit in the pattern)</li>
<li>Pattern ID (a unique number representing the pattern; higher pattern IDs are
straighter)</li>
<li>Collection of 6 centroids (describes the position of a hit within the pattern
mask)</li>
</ol>
</div>

<div id="outline-container-org7e9a04f" class="outline-4">
<h4 id="org7e9a04f">Centroid finding</h4>
<div class="outline-text-4" id="text-org7e9a04f">
<p>
To minimize resource usage and keep acceptance high, the patterns are defined to
be fairly wide. To avoid losing resolution in this wide patterns, however, along
with each layer of a pattern a centroid is found and saved for later stages of
processing.
</p>

<pre class="example" id="orgd670e9e">
┌─────────────────────────────────────┐
│-------------xx+x--------------------│
│--------------xx+x-------------------│
│----------------x+x------------------│
│----------------xx+------------------│
│------------------x+xxx--------------│
│-------------------x+xxx-------------│
└─────────────────────────────────────┘
 -18    &lt;--       0       --&gt;       18
</pre>

<p>
For example, in the pattern above we have six layers composed of:
</p>

<pre class="example">
   01234
1. xx+x   centroid = 2
2. xx+x   centroid = 2
3. x+x    centroid = 1
4. xx+    centroid = 3
5. x+xxx  centroid = 1
6. x+xxx  centroid = 1
</pre>

<p>
The centroid simply describes the location of the charge cluster within the
pattern mask.
</p>

<p>
This is used during a later stage of the firmware to convert the location within
the centroid into a location relative to the center of the pattern unit.
</p>

<p>
In many/most cases more than 1 adjacent strip will be fired. In this case the
centroid finder produces some estimate of the center of the charge cluster.
</p>

<p>
e.g. This example will produce a centroid of 3, since it is the center of the 3
active strips.
</p>

<pre class="example">
0123456
xx+++xx
   ^ centroid = 3
</pre>

<p>
The implementation of the centroid finder is a lookup-table generated by a
python script, so the firmware is flexible to accomodate different algorithms
for centroid finding.
</p>
</div>
</div>

<div id="outline-container-org1836f5d" class="outline-4">
<h4 id="org1836f5d">Edge Padding</h4>
<div class="outline-text-4" id="text-org1836f5d">
<p>
(Some pattern units run off the left and right edges of the chamber and need to
be zero-padded)
</p>
</div>
</div>
</div>
<div id="outline-container-org9e654e6" class="outline-3">
<h3 id="org9e654e6">Ghost Cancellation</h3>
<div class="outline-text-3" id="text-org9e654e6">
<p>
(because of wide patterns, the same hits will produce multiple strips.. cancel
off these neighboring &ldquo;ghosts&rdquo;)
</p>
</div>
</div>
<div id="outline-container-org842d6bd" class="outline-3">
<h3 id="org842d6bd">Partition Pre-Sorting</h3>
<div class="outline-text-3" id="text-org842d6bd">
<p>
For each partition, every bunch crossing a collection of 192 segments is
produced in the pattern units.
</p>

<p>
This will be later sent into &ldquo;true&rdquo; bitonic sorters, but to reduce the
computational difficulty of the bitonic sorting stage, the segments are first
passed through a crude sorting tree.
</p>

<p>
This takes advantage of the fact that generally we are less interested in
multiple segments appearing in neighboring partitions, since they will often
simply be ghosts of one another.
</p>

<p>
Thus, we restrict the chamber to only accept one segment for every N strips,
reducing the # of segments that need to be sorted by a factor of N.
</p>
</div>
</div>

<div id="outline-container-org9c51f7f" class="outline-3">
<h3 id="org9c51f7f">Chamber Segment Selection</h3>
<div class="outline-text-3" id="text-org9c51f7f">
<p>
Choose from (8 partitions * 192/N segments) -&gt; M segments, where N is the
pre-sorting factor from the previous stage.
</p>
</div>
</div>
<div id="outline-container-orgc7383af" class="outline-3">
<h3 id="orgc7383af">Centroid Coordinate Transformation</h3>
<div class="outline-text-3" id="text-orgc7383af">
<p>
<i>f</i> (<code>pattern id</code>, <code>6x centroids</code>) → 6x hit position
</p>
</div>
</div>

<div id="outline-container-org8fc50eb" class="outline-3">
<h3 id="org8fc50eb">Fitting</h3>
<div class="outline-text-3" id="text-org8fc50eb">
<p>
A standard linear fit follows a formula:
</p>

<p>
\[
  \overline{X}=\frac{\sum{}{}x_i}{n}
\]
</p>

<p>
\[
  \overline{Y}=\frac{\sum{}{}y_i}{n}
\]
</p>

<p>
\[
  m = \frac {\sum{}{}(x_i - \overline{X})(y_i-\overline{Y})}{\sum{}{} (x_i-\overline{X})^2}
\]
</p>

<p>
\[
  b = \overline{Y} - m\overline{X}
\]
</p>

<p>
To reduce the computational difficulty in an FPGA, we modify this formula in a few ways.
</p>

<p>
To defer a division by n and continue more of the calculation in signed
arithmetic (rather than fixed point), we instead calculate:
</p>

\begin{align*}
  m =& \frac {\sum{}{}(x_i - \overline{X})(y_i-\overline{Y})}{\sum{}{} (x_i-\overline{X})^2} \\
    =& \frac {\sum{}{}(x - \frac{\sum{}{}x_i}{n})(y-\frac{\sum{}{}x_i}{n})}{\sum{}{} (x-\frac{\sum{}{}x_i}{n})^2} \\
    =& \frac{n}{n} \frac {\sum{}{}(x - \frac{\sum{}{}x_i}{n})(y-\frac{\sum{}{}x_i}{n})}{\sum{}{} (x-\frac{\sum{}{}x_i}{n})^2} \\
    =& \frac {\sum{}{}(nx - \sum{}{}{x_{i}})(ny_i-\sum{}{}{y_i})} {\sum{}{} (nx_{i}-\sum{}{}x_{i})^2}
\end{align*}

<p>
To make this even simpler, we take advantage of the fact that the range of the
divisor in the above equation is limited to a maximum value of 630.
</p>

<p>
This is because the <code>x</code> values represent the layer count, which is simply the set
of layers hit (0, 1, 2, 3, 4, 5) where not all layers are necessarily hit.
</p>

<p>
The upper bound on this number then is just:
</p>

<p>
\[
630 = 6^2 \times ( (0 - 2.5)^2 + (1 - 2.5)^2 + (2 - 2.5)^2 + (3 - 2.5)^2 + (4 - 2.5)^2 + (5 - 2.5)^2 )
\]
</p>

<p>
This was found by brute force exhausting the entire possibility of combinations.
</p>

<p>
Since the divisor only has a small range of values possible, the division is
re-written as a multiplication by the reciprocal of the number. All possible
values of this are encoded in a lookup table as a fixed point value. This
transforms a division into a fixed point multiplication, which is
computationally much simpler.
</p>


<p>
\[
  m =
  \sum{}{}(nx - \sum{}{}{x_{i}})(ny_i-\sum{}{}{y_i})
  \times reciprocal(\sum{}{} (nx_{i}-\sum{}{}x_{i})^2)
\]
</p>


<p>
With this, the slope is still expressed by the same formula as above, with a
multiplication by a factor of 1/n (stored in a lookup table) used in place of a
division by n.
</p>

<p>
\[
  b = \overline{Y} - m\overline{X} = \frac{\sum{}{}y_i}{n} - m \frac{\sum{}{}x_i}{n}
  = \frac{\sum{}{}y_i - m \sum{}{}x_i}{n}
  = (\sum{}{}y_i - m \sum{}{}x_i) \times reciprocal(n)
\]
</p>

<p>
This intercept (<code>b</code>) represents the intercept in a coordinate system where the
layers are numbered (0 1 2 3 4 5) and so the intercept is the strip along the
edge of the chamber (on the 0th layer).
</p>

<p>
To better represent the pattern and make the intercept in the center of the
chamber, we do a simple coordinate transformation:
</p>

<p>
\[
strip = m \times 2.5 + b
\]
</p>

<p>
The number 2.5 is chosen so that the center of the chamber is at 0, with the
layers at ±0.5, ±1.5, ±2.5. The output of the fit module is therefore the strip
and slope centered in the midpoint of the chamber. Both numbers are output as
fixed point numbers.
</p>

<p>
e.g., for the strip output,
</p>
<ul class="org-ul">
<li>the number is composed of an integer and decimal part. The integer part
represents the strip in integer units. Since the patterns are constructed
such that the tracks are <i>always</i> centered around the midpoint of the pattern
unit, the integer part of this need only be a few bits to represent the
offset from center.</li>
<li>the fractional part is such that
<ul class="org-ul">
<li>fractional bit 0 = 1/2 strip</li>
<li>fractional bit 1 = 1/4 strip</li>
<li>fractional bit 2 = 1/8 strip</li>
<li>and so on..</li>
</ul></li>
</ul>

<p>
For the slope output, it is similarly represented in fixed point format, with
units of strips/layer. A slope of 0 is a straight track, and a slope of 7 is
extremely angled.
</p>

<p>
The fit operates in a relatively high resolution output by default, but the
resolution can be truncated for sending upstream by simply truncating off
fractional bits to achieve the desired bandwidth.
</p>

<p>
Studies are needed to determine the optional (and achievable) resolution from
this fit.
</p>
</div>

<div id="outline-container-org647abfa" class="outline-4">
<h4 id="org647abfa">Quality of Fit</h4>
<div class="outline-text-4" id="text-org647abfa">
<p>
how to calculate??
</p>
</div>
</div>

<div id="outline-container-orgd93c620" class="outline-4">
<h4 id="orgd93c620">Pipelined Multiplication</h4>
<div class="outline-text-4" id="text-orgd93c620">
<p>
Some steps of the fit (multiplications) are pipelined into multiple (2) clock cycles.
</p>

<p>
The basic scheme of the pipelined multiplication is to split the numbers into
most-significant and least-significant parts, and multiply the parts
independently, summing their products at the end.
</p>

<p>
e.g. consider the multiplication of two 16 bit numbers, A and B:
</p>

\begin{align*}
A \times B =& A[15:0] \times B[15:0]  \\
           =& (A[15:8] \cdot 2^8 + A[7:0]) \times (B[15:8] \cdot 2^8 + B[7:0])  \\
           =& (A_{HI} \cdot 2^8 + A_{LO}) \times (B_{HI} \cdot 2^8 + B_{LO})  \\
           =& (A_{HI} \cdot 1^8 + A_{LO}) \times (B_{HI} \cdot 2^8 + B_{LO})  \\
           =& (A_{HI} \cdot B_{HI} \cdot 2^{16}) + (A_{HI} \cdot B_{LO} \cdot 2^8) + (A_{LO} \cdot B_{HI} \cdot 2^8) + (A_{LO} \cdot B_{LO}) \\
           =& (A_{HI} \cdot B_{HI} << 16) + (A_{HI} \cdot B_{LO} \cdot << 8) + (A_{LO} \cdot B_{HI} \cdot << 8) + (A_{LO} \cdot B_{LO}) \\
\end{align*}

<p>
So, we are able to split a 16x16 bit multiplication into two steps: (1) four 8x8
bit multiplications w/ bitshifting (2) three additions. This allows us to
pipeline the multiplication into two clock cycles and achieve timing at 320 MHz.
Bitshifting is &ldquo;free&rdquo; in the FPGA (just zero padding) so this can easily meet
timing.
</p>
</div>
</div>

<div id="outline-container-orgfdd8ea0" class="outline-4">
<h4 id="orgfdd8ea0">Reciprocal</h4>
<div class="outline-text-4" id="text-orgfdd8ea0">
<p>
The lookup table for the reciprocal LUT is calculated through a simple python script:
</p>

<div class="org-src-container">
<pre class="src src-python">
<span class="org-builtin">print</span>(<span class="org-string">""</span>.join([
    <span class="org-string">"  function reciprocal (x : integer; nbits : integer) return sfixed is\n"</span>,
    <span class="org-string">"  begin\n"</span>,
    <span class="org-string">"    if (x&lt;1 or x&gt; 2047) then \n"</span>,
    <span class="org-string">"      assert false report \"invalid reciprocal lookup x=\" &amp; integer\'image(x) severity error;\n"</span>,
    <span class="org-string">"      return to_sfixed(0, 1, -nbits);\n"</span>,
    <span class="org-string">""</span>.join(<span class="org-builtin">list</span>(<span class="org-builtin">map</span>(<span class="org-keyword">lambda</span> i :
                     <span class="org-string">"    elsif (x=%d) then return to_sfixed(%.20f, 1, -nbits);\n"</span> % (i, <span class="org-highlight-numbers-number">1</span>/i),
                     <span class="org-builtin">range</span>(<span class="org-highlight-numbers-number">1</span>, <span class="org-highlight-numbers-number">2048</span>)))),
    <span class="org-string">"    end if;\n"</span>,
    <span class="org-string">"  end;\n"</span>]))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga741308" class="outline-3">
<h3 id="orga741308">Post-Fit Coordinate Transformation</h3>
<div class="outline-text-3" id="text-orga741308">
<p>
Transform from local to global coordinates (this is just addition of strip + fit_offset)
</p>

<p>
f (pat_unit_strip, fit_offset) -&gt; strip
</p>
</div>
</div>

<div id="outline-container-org6a2bc70" class="outline-3">
<h3 id="org6a2bc70">Output Data Format</h3>
<div class="outline-text-3" id="text-org6a2bc70">
<p>
The currently proposed output data format is:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Field</th>
<th scope="col" class="org-right">Bits</th>
<th scope="col" class="org-left">Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Eta</td>
<td class="org-right">4</td>
<td class="org-left">16 eta positions (stubs can&rsquo;t cross more than 2 partitions)</td>
</tr>

<tr>
<td class="org-left">Phi</td>
<td class="org-right">10</td>
<td class="org-left">768 phi positions (&ldquo;half strip&rdquo; resolution)</td>
</tr>

<tr>
<td class="org-left">Bend</td>
<td class="org-right">9</td>
<td class="org-left">512 different bend angles</td>
</tr>

<tr>
<td class="org-left">Quality</td>
<td class="org-right">4</td>
<td class="org-left">16 different quality levels</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">Total</td>
<td class="org-right">27</td>
<td class="org-left">Bits per Segment</td>
</tr>
</tbody>
</table>
</div>

<div id="outline-container-org1d308ec" class="outline-4">
<h4 id="org1d308ec">Eta</h4>
</div>
<div id="outline-container-orgceb5a37" class="outline-4">
<h4 id="orgceb5a37">Phi</h4>
<div class="outline-text-4" id="text-orgceb5a37">
<p>
Phi is encoded as a number from 0-768
</p>

<p>
The resolution of the trigger primitive is in the OR of two adjacent strips
(0-191) so this is a factor of 4 increase in nominal resolution.
</p>
</div>
</div>

<div id="outline-container-org10cfb51" class="outline-4">
<h4 id="org10cfb51">Bend</h4>
<div class="outline-text-4" id="text-org10cfb51">
<p>
The bend angle is encoded as a fixed point number
</p>
<ul class="org-ul">
<li>4 bits integer bend (units of strips/layer, twos complement signed number)</li>
<li>5 bits fractional bend</li>
</ul>

<p>
In fixed point fashion, the interpretation of the fractional bend is that
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Bit</th>
<th scope="col" class="org-left">Resolution</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">bit0</td>
<td class="org-left">1/2 strip/layer</td>
</tr>

<tr>
<td class="org-left">bit1</td>
<td class="org-left">1/4 strip/layer</td>
</tr>

<tr>
<td class="org-left">bit2</td>
<td class="org-left">1/8 strip/layer</td>
</tr>

<tr>
<td class="org-left">bit3</td>
<td class="org-left">1/16 strip/layer</td>
</tr>

<tr>
<td class="org-left">bit4</td>
<td class="org-left">1/32 strip/layer</td>
</tr>
</tbody>
</table>

<p>
The resolution may be reduced later after further studies are done.
</p>
</div>
</div>

<div id="outline-container-org5bec022" class="outline-4">
<h4 id="org5bec022">Quality</h4>
</div>
</div>
</div>

<div id="outline-container-orgd03caed" class="outline-2">
<h2 id="orgd03caed">Firmware Implementation</h2>
<div class="outline-text-2" id="text-orgd03caed">
</div>
<div id="outline-container-org950602d" class="outline-3">
<h3 id="org950602d">Configurable Options</h3>
<div class="outline-text-3" id="text-org950602d">
</div>
<div id="outline-container-org68ce93e" class="outline-4">
<h4 id="org68ce93e">Compile Time Options</h4>
<div class="outline-text-4" id="text-org68ce93e">
</div>
<ul class="org-ul">
<li><a id="org649e164"></a>Pattern definitions<br /></li>
<li><a id="org5169712"></a>Multiplexing factors<br /></li>
<li><a id="org1178e26"></a>Fitting resolution<br /></li>
<li><a id="org6ed1e9b"></a>Number of output segments<br /></li>
</ul>
</div>
<div id="outline-container-orgd5ce02c" class="outline-4">
<h4 id="orgd5ce02c">Runtime Options</h4>
<div class="outline-text-4" id="text-orgd5ce02c">
</div>
<ul class="org-ul">
<li><a id="org4748822"></a>Layer threshold<br /></li>
<li><a id="orgbca82a2"></a>Pattern enables<br /></li>
</ul>
</div>
</div>
<div id="outline-container-org846ac42" class="outline-3">
<h3 id="org846ac42">Firmware</h3>
<div class="outline-text-3" id="text-org846ac42">
</div>
<div id="outline-container-org2009a27" class="outline-4">
<h4 id="org2009a27">pat_unit.vhd</h4>
</div>
<div id="outline-container-org6e3f322" class="outline-4">
<h4 id="org6e3f322">pat_unit_mux.vhd</h4>
</div>
<div id="outline-container-orge1c5f6b" class="outline-4">
<h4 id="orge1c5f6b">partition.vhd</h4>
</div>
<div id="outline-container-orgeb6de65" class="outline-4">
<h4 id="orgeb6de65">segment_selector.vhd</h4>
</div>
<div id="outline-container-org873cbdd" class="outline-4">
<h4 id="org873cbdd">fit.vhd</h4>
</div>
</div>
</div>
<div id="outline-container-org4f57d57" class="outline-2">
<h2 id="org4f57d57">Testbench</h2>
<div class="outline-text-2" id="text-org4f57d57">
<p>
The firmware is tested against a standalone Python emulator, using CocoTB as the
test runner and Questasim (or modelsim, or Aldec Riviera) as the simulator.
</p>
</div>
</div>

<div id="outline-container-orga5f9b82" class="outline-2">
<h2 id="orga5f9b82">Resource Utilization</h2>
<div class="outline-text-2" id="text-orga5f9b82">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">LUT</th>
<th scope="col" class="org-right">FF</th>
<th scope="col" class="org-right">DSP</th>
<th scope="col" class="org-left">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Fitting</td>
<td class="org-right">1627</td>
<td class="org-right">763</td>
<td class="org-right">0</td>
<td class="org-left">Runs at 320MHz, can do 8x fits per bx</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgc7e0fa6" class="outline-2">
<h2 id="orgc7e0fa6">Presentations</h2>
<div class="outline-text-2" id="text-orgc7e0fa6">
<ul class="org-ul">
<li><a href="https://docs.google.com/presentation/d/10K-16xrXGUYcb-aZzMEEbbvJrTAYdaBR/edit#slide=id.ga773dc3468_0_22">https://docs.google.com/presentation/d/10K-16xrXGUYcb-aZzMEEbbvJrTAYdaBR/edit#slide=id.ga773dc3468_0_22</a></li>
</ul>
</div>
</div>
<div id="outline-container-org5f2bc8c" class="outline-2">
<h2 id="org5f2bc8c">Source Code</h2>
<div class="outline-text-2" id="text-org5f2bc8c">
<ul class="org-ul">
<li>Firmware: <a href="https://github.com/andrewpeck/me0sf/">https://github.com/andrewpeck/me0sf/</a></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2022-08-05 Fri 19:34</p>
</div>
</body>
</html>
